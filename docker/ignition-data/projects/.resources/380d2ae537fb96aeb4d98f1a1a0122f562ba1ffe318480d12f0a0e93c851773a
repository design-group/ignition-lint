def doGet(request, session):
	"""
	Test endpoint for Redis advanced operations (batch, pipeline, advanced SET variants)
	GET /test-redis-advanced - Lists all advanced operations
	GET /test-redis-advanced?action=set_ifnotexists&key=test&value=hello - SET with ifNotExists
	GET /test-redis-advanced?action=batch&ops=op1:set:key1:val1,op2:get:key2 - Batch operations
	"""

	try:
		# Get URL parameters correctly
		params = request['params']
		action = params.get('action', 'list')
		if isinstance(action, list):
			action = action[0] if action else 'list'

		if action == 'list':
			# Return available Redis advanced operations
			return {
				'json': {
					'success': True,
					'operations': [
						'set_ifnotexists - SET with ifNotExists condition',
						'set_ttl_millis - SET with TTL in milliseconds',
						'set_expiration_date - SET with absolute expiration date',
						'batch - Execute batch operations',
						'create_batch_op - Create batch operation objects',
						'pipeline - Execute pipeline operations',
						'hset_map - HSET with multiple fields as Map',
						'zadd_single - ZADD single member to sorted set'
					],
					'examples': {
						'set_ifnotexists': '/test-redis-advanced?action=set_ifnotexists&key=test:nx&value=only_if_new',
						'set_ttl_millis': '/test-redis-advanced?action=set_ttl_millis&key=test:ttl&value=expires&ttl=5000',
						'batch': '/test-redis-advanced?action=batch&ops=op1:set:key1:val1,op2:get:key2',
						'pipeline': '/test-redis-advanced?action=pipeline&ops=set:key1:val1:300:true,get:key2',
						'hset_map': '/test-redis-advanced?action=hset_map&key=test:hash&fields=name:john,age:30'
					}
				}
			}

		elif action == 'set_ifnotexists':
			key = params.get('key')
			if isinstance(key, list):
				key = key[0] if key else None
			if not key:
				return {'json': {'success': False, 'error': 'Missing required parameter: key'}}

			value = params.get('value')
			if isinstance(value, list):
				value = value[0] if value else None
			if not value:
				return {'json': {'success': False, 'error': 'Missing required parameter: value'}}

			try:
				# SET with ifNotExists=True
				system.redis.set('redis', key, value, ifNotExists=True)

				return {
					'json': {
						'success': True,
						'message': 'Key set with ifNotExists condition',
						'key': key,
						'value': value,
						'condition': 'ifNotExists'
					}
				}
			except Exception as e:
				return {
					'json': {
						'success': False,
						'error': str(e),
						'key': key
					}
				}

		elif action == 'set_ttl_millis':
			key = params.get('key')
			if isinstance(key, list):
				key = key[0] if key else None
			if not key:
				return {'json': {'success': False, 'error': 'Missing required parameter: key'}}

			value = params.get('value')
			if isinstance(value, list):
				value = value[0] if value else None
			if not value:
				return {'json': {'success': False, 'error': 'Missing required parameter: value'}}

			ttl = params.get('ttl')
			if isinstance(ttl, list):
				ttl = ttl[0] if ttl else None
			if not ttl:
				return {'json': {'success': False, 'error': 'Missing required parameter: ttl'}}

			try:
				# SET with TTL in milliseconds
				system.redis.set('redis', key, value, ttlMillis=int(ttl))

				return {
					'json': {
						'success': True,
						'message': 'Key set with TTL in milliseconds',
						'key': key,
						'value': value,
						'ttl_millis': int(ttl)
					}
				}
			except Exception as e:
				return {
					'json': {
						'success': False,
						'error': str(e),
						'key': key
					}
				}

		elif action == 'set_expiration_date':
			key = params.get('key')
			if isinstance(key, list):
				key = key[0] if key else None
			if not key:
				return {'json': {'success': False, 'error': 'Missing required parameter: key'}}

			value = params.get('value')
			if isinstance(value, list):
				value = value[0] if value else None
			if not value:
				return {'json': {'success': False, 'error': 'Missing required parameter: value'}}

			seconds_from_now = params.get('seconds_from_now', '10')
			if isinstance(seconds_from_now, list):
				seconds_from_now = seconds_from_now[0] if seconds_from_now else '10'

			try:
				import datetime
				# Create expiration date N seconds from now
				expiration_date = datetime.datetime.now() + datetime.timedelta(seconds=int(seconds_from_now))

				# SET with absolute expiration date
				system.redis.set('redis', key, value, expirationDate=expiration_date)

				return {
					'json': {
						'success': True,
						'message': 'Key set with absolute expiration date',
						'key': key,
						'value': value,
						'expiration_date': str(expiration_date),
						'seconds_from_now': int(seconds_from_now)
					}
				}
			except Exception as e:
				return {
					'json': {
						'success': False,
						'error': str(e),
						'key': key
					}
				}

		elif action == 'batch':
			ops_param = params.get('ops')
			if isinstance(ops_param, list):
				ops_param = ops_param[0] if ops_param else None
			if not ops_param:
				return {'json': {'success': False, 'error': 'Missing required parameter: ops'}}

			try:
				# Parse operations: "op1:set:key1:val1,op2:get:key2"
				# Note: Keys can contain colons, so we need to be more careful about parsing
				operations = []
				for op_str in ops_param.split(','):
					parts = op_str.strip().split(':')
					if len(parts) < 3:
						continue

					op_id = parts[0]
					op_type = parts[1]

					# For SET operations, we need to find where the key ends and value starts
					# Format: op_id:op_type:key:value[:ttl][:ifnotexists]
					if op_type == 'set':
						if len(parts) < 4:
							continue  # SET needs at least id:type:key:value

						# The tricky part: where does key end and value start?
						# We'll assume the value is the second-to-last or third-to-last part
						# depending on whether TTL/ifNotExists are present

						if len(parts) == 4:
							# op_id:op_type:key:value
							op_key = parts[2]
							value = parts[3]
							ttl = None
							if_not_exists = None
						elif len(parts) == 5:
							# Could be op_id:op_type:key:value:ttl OR op_id:op_type:key_with_colon:value
							if parts[4].isdigit():
								# op_id:op_type:key:value:ttl
								op_key = parts[2]
								value = parts[3]
								ttl = int(parts[4])
								if_not_exists = None
							else:
								# op_id:op_type:key_with_colon:value
								op_key = parts[2] + ':' + parts[3]
								value = parts[4]
								ttl = None
								if_not_exists = None
						elif len(parts) == 6:
							# Could be several combinations, check if last is boolean and second-to-last is digit
							if parts[4].isdigit() and parts[5].lower() in ['true', 'false']:
								# op_id:op_type:key:value:ttl:ifnotexists
								op_key = parts[2]
								value = parts[3]
								ttl = int(parts[4])
								if_not_exists = parts[5].lower() == 'true'
							elif parts[5].isdigit():
								# op_id:op_type:key_with_colon:value:ttl
								op_key = parts[2] + ':' + parts[3]
								value = parts[4]
								ttl = int(parts[5])
								if_not_exists = None
							else:
								# op_id:op_type:key_with_colon:value
								op_key = parts[2] + ':' + parts[3] + ':' + parts[4]
								value = parts[5]
								ttl = None
								if_not_exists = None
						elif len(parts) >= 7:
							# op_id:op_type:key_with_colons:value:ttl:ifnotexists
							# Find the last 3 parts: value, ttl (digit), ifnotexists (boolean)
							if parts[-1].lower() in ['true', 'false'] and parts[-2].isdigit():
								# Last two are ttl and ifnotexists
								op_key = ':'.join(parts[2:-3])
								value = parts[-3]
								ttl = int(parts[-2])
								if_not_exists = parts[-1].lower() == 'true'
							elif parts[-1].isdigit():
								# Last one is ttl
								op_key = ':'.join(parts[2:-2])
								value = parts[-2]
								ttl = int(parts[-1])
								if_not_exists = None
							else:
								# No TTL/ifnotexists, last part is value
								op_key = ':'.join(parts[2:-1])
								value = parts[-1]
								ttl = None
								if_not_exists = None

						batch_op = system.redis.createBatchOperation(op_id, op_type)
						batch_op.key(op_key)
						batch_op.value(value)

						if ttl is not None:
							batch_op.ttlSeconds(ttl)
						if if_not_exists is not None:
							batch_op.ifNotExists(if_not_exists)

					elif op_type == 'get':
						# For GET: op_id:op_type:key (key can have colons)
						op_key = ':'.join(parts[2:])  # Everything after op_type is the key
						batch_op = system.redis.createBatchOperation(op_id, op_type)
						batch_op.key(op_key)

					elif op_type == 'hset':
						# For HSET: op_id:op_type:key:field:value
						if len(parts) < 5:
							continue
						# Assume field and value don't contain colons, but key might
						op_key = ':'.join(parts[2:-2])  # Everything except last 2 parts
						field = parts[-2]
						value = parts[-1]
						batch_op = system.redis.createBatchOperation(op_id, op_type)
						batch_op.key(op_key)
						batch_op.field(field)
						batch_op.value(value)

					elif op_type == 'hget':
						# For HGET: op_id:op_type:key:field
						if len(parts) < 4:
							continue
						# Assume field doesn't contain colons, but key might
						op_key = ':'.join(parts[2:-1])  # Everything except last part
						field = parts[-1]
						batch_op = system.redis.createBatchOperation(op_id, op_type)
						batch_op.key(op_key)
						batch_op.field(field)

					else:
						# For other operations: op_id:op_type:key
						op_key = ':'.join(parts[2:])
						batch_op = system.redis.createBatchOperation(op_id, op_type)
						batch_op.key(op_key)

					operations.append(batch_op)

				# Execute batch
				results = system.redis.batch('redis', operations)

				return {
					'json': {
						'success': True,
						'message': 'Batch operations executed',
						'operation_count': len(operations),
						'results': results
					}
				}
			except Exception as e:
				return {
					'json': {
						'success': False,
						'error': str(e),
						'ops': ops_param
					}
				}

		elif action == 'pipeline':
			ops_param = params.get('ops')
			if isinstance(ops_param, list):
				ops_param = ops_param[0] if ops_param else None
			if not ops_param:
				return {'json': {'success': False, 'error': 'Missing required parameter: ops'}}

			try:
				# Parse operations: "set:key1:val1:300:true,get:key2"
				# Note: Keys can contain colons, so we need careful parsing
				pipeline = system.redis.pipeline('redis')

				for op_str in ops_param.split(','):
					parts = op_str.strip().split(':')
					if len(parts) < 2:
						continue

					op_type = parts[0]

					if op_type == 'set':
						if len(parts) < 3:
							continue  # SET needs at least type:key:value

						# Parse similar to batch operations
						if len(parts) == 3:
							# set:key:value
							op_key = parts[1]
							value = parts[2]
							ttl_seconds = None
							if_not_exists = False
						elif len(parts) == 4:
							# Could be set:key:value:ttl OR set:key_with_colon:value
							if parts[3].isdigit():
								# set:key:value:ttl
								op_key = parts[1]
								value = parts[2]
								ttl_seconds = int(parts[3])
								if_not_exists = False
							else:
								# set:key_with_colon:value
								op_key = parts[1] + ':' + parts[2]
								value = parts[3]
								ttl_seconds = None
								if_not_exists = False
						elif len(parts) == 5:
							# Could be set:key:value:ttl:ifnotexists OR set:key_with_colon:value:ttl
							if parts[3].isdigit() and parts[4].lower() in ['true', 'false']:
								# set:key:value:ttl:ifnotexists
								op_key = parts[1]
								value = parts[2]
								ttl_seconds = int(parts[3])
								if_not_exists = parts[4].lower() == 'true'
							elif parts[4].isdigit():
								# set:key_with_colon:value:ttl
								op_key = parts[1] + ':' + parts[2]
								value = parts[3]
								ttl_seconds = int(parts[4])
								if_not_exists = False
							else:
								# set:key_with_colons:value
								op_key = parts[1] + ':' + parts[2] + ':' + parts[3]
								value = parts[4]
								ttl_seconds = None
								if_not_exists = False
						elif len(parts) >= 6:
							# set:key_with_colons:value:ttl:ifnotexists
							# Filter out empty parts that can result from trailing colons
							filtered_parts = [p for p in parts if p != '']
							if len(filtered_parts) != len(parts):
								parts = filtered_parts

							if len(parts) >= 6 and parts[-1].lower() in ['true', 'false'] and parts[-2].isdigit():
								# Last two are ttl and ifnotexists
								op_key = ':'.join(parts[1:-3])
								value = parts[-3]
								ttl_seconds = int(parts[-2])
								if_not_exists = parts[-1].lower() == 'true'
							elif len(parts) >= 5 and parts[-1].isdigit():
								# Last one is ttl
								op_key = ':'.join(parts[1:-2])
								value = parts[-2]
								ttl_seconds = int(parts[-1])
								if_not_exists = False
							else:
								# No TTL/ifnotexists, last part is value
								op_key = ':'.join(parts[1:-1])
								value = parts[-1]
								ttl_seconds = None
								if_not_exists = False

						if ttl_seconds and if_not_exists:
							pipeline.set(op_key, value, ttl_seconds, if_not_exists)
						elif ttl_seconds:
							pipeline.set(op_key, value, ttl_seconds)
						elif if_not_exists:
							pipeline.set(op_key, value, if_not_exists)
						else:
							pipeline.set(op_key, value)
					elif op_type == 'get':
						# For GET: type:key (key can have colons)
						op_key = ':'.join(parts[1:])
						pipeline.get(op_key)
					elif op_type == 'delete':
						# For DELETE: type:key (key can have colons)
						op_key = ':'.join(parts[1:])
						pipeline.delete(op_key)
					elif op_type == 'exists':
						# For EXISTS: type:key (key can have colons)
						op_key = ':'.join(parts[1:])
						pipeline.exists(op_key)

				# Execute pipeline
				results = pipeline.execute()

				return {
					'json': {
						'success': True,
						'message': 'Pipeline operations executed',
						'operation_count': len(results),
						'results': list(results)
					}
				}
			except Exception as e:
				return {
					'json': {
						'success': False,
						'error': str(e),
						'ops': ops_param
					}
				}

		elif action == 'hset_map':
			key = params.get('key')
			if isinstance(key, list):
				key = key[0] if key else None
			if not key:
				return {'json': {'success': False, 'error': 'Missing required parameter: key'}}

			fields_param = params.get('fields')
			if isinstance(fields_param, list):
				fields_param = fields_param[0] if fields_param else None
			if not fields_param:
				return {'json': {'success': False, 'error': 'Missing required parameter: fields'}}

			try:
				# Parse fields: "name:john,age:30,active:true"
				field_values = {}
				for field_str in fields_param.split(','):
					field_parts = field_str.strip().split(':')
					if len(field_parts) >= 2:
						field_name = field_parts[0]
						field_value = ':'.join(field_parts[1:])  # Handle values with colons
						field_values[field_name] = field_value

				# HSET with Map parameter
				system.redis.hset('redis', key, field_values)

				return {
					'json': {
						'success': True,
						'message': 'Hash fields set with Map parameter',
						'key': key,
						'field_values': field_values,
						'field_count': len(field_values)
					}
				}
			except Exception as e:
				return {
					'json': {
						'success': False,
						'error': str(e),
						'key': key
					}
				}

		elif action == 'zadd_single':
			key = params.get('key')
			if isinstance(key, list):
				key = key[0] if key else None
			if not key:
				return {'json': {'success': False, 'error': 'Missing required parameter: key'}}

			member = params.get('member')
			if isinstance(member, list):
				member = member[0] if member else None
			if not member:
				return {'json': {'success': False, 'error': 'Missing required parameter: member'}}

			score = params.get('score')
			if isinstance(score, list):
				score = score[0] if score else None
			if not score:
				return {'json': {'success': False, 'error': 'Missing required parameter: score'}}

			try:
				# ZADD single member
				added_count = system.redis.zadd('redis', key, member, float(score))

				return {
					'json': {
						'success': True,
						'message': 'Single member added to sorted set',
						'key': key,
						'member': member,
						'score': float(score),
						'added_count': added_count
					}
				}
			except Exception as e:
				return {
					'json': {
						'success': False,
						'error': str(e),
						'key': key
					}
				}

		else:
			return {'json': {'success': False, 'error': 'Unknown action: ' + str(action)}}

	except Exception as e:
		import traceback
		return {
			'json': {
				'success': False,
				'error': str(e),
				'type': type(e).__name__,
				'traceback': traceback.format_exc()
			}
		}
