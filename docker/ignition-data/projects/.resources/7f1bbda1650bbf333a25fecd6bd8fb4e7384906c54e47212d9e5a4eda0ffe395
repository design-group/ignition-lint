def doGet(request, session):
	"""
	Test endpoint for Redis basic operations (GET, SET, DELETE, EXISTS)
	GET /test-redis-basic - Lists all basic operations
	GET /test-redis-basic?action=set&key=test&value=hello - Sets a key-value pair
	GET /test-redis-basic?action=get&key=test - Gets a value by key
	"""

	try:
		# Get URL parameters correctly
		params = request['params']
		action = params.get('action', 'list')
		if isinstance(action, list):
			action = action[0] if action else 'list'

		if action == 'list':
			# Return available Redis operations
			return {
				'json': {
					'success': True,
					'operations': [
						'set - Set a key-value pair in Redis',
						'get - Get a value by key from Redis',
						'delete - Delete a key from Redis',
						'exists - Check if a key exists in Redis',
						'keys - Get all keys matching a pattern'
					],
					'examples': {
						'set': '/test-redis-basic?action=set&key=user:123&value=john_doe',
						'get': '/test-redis-basic?action=get&key=user:123',
						'delete': '/test-redis-basic?action=delete&key=user:123',
						'exists': '/test-redis-basic?action=exists&key=user:123',
						'keys': '/test-redis-basic?action=keys&pattern=user:*'
					}
				}
			}

		elif action == 'set':
			key = params.get('key')
			if isinstance(key, list):
				key = key[0] if key else None
			if not key:
				return {'json': {'success': False, 'error': 'Missing required parameter: key'}}

			value = params.get('value')
			if isinstance(value, list):
				value = value[0] if value else None
			if not value:
				return {'json': {'success': False, 'error': 'Missing required parameter: value'}}

			# Optional TTL parameter
			ttl = params.get('ttl')
			if isinstance(ttl, list):
				ttl = ttl[0] if ttl else None

			try:
				# Set the value using system.redis directly
				if ttl:
					system.redis.set('redis', key, value, ttlSeconds=int(ttl))
				else:
					system.redis.set('redis', key, value)

				return {
					'json': {
						'success': True,
						'message': 'Key set successfully',
						'key': key,
						'value': value,
						'ttl': ttl
					}
				}
			except Exception as e:
				return {
					'json': {
						'success': False,
						'error': str(e),
						'key': key
					}
				}

		elif action == 'get':
			key = params.get('key')
			if isinstance(key, list):
				key = key[0] if key else None
			if not key:
				return {'json': {'success': False, 'error': 'Missing required parameter: key'}}

			try:
				# Get the value using system.redis directly
				value = system.redis.get('redis', key)

				return {
					'json': {
						'success': True,
						'key': key,
						'value': value
					}
				}
			except Exception as e:
				return {
					'json': {
						'success': False,
						'error': str(e),
						'key': key
					}
				}

		elif action == 'delete':
			key = params.get('key')
			if isinstance(key, list):
				key = key[0] if key else None
			if not key:
				return {'json': {'success': False, 'error': 'Missing required parameter: key'}}

			try:
				# Delete the key using system.redis directly
				deleted_count = system.redis.delete('redis', key)

				return {
					'json': {
						'success': True,
						'key': key,
						'deleted': deleted_count > 0,
						'deleted_count': deleted_count
					}
				}
			except Exception as e:
				return {
					'json': {
						'success': False,
						'error': str(e),
						'key': key
					}
				}

		elif action == 'exists':
			key = params.get('key')
			if isinstance(key, list):
				key = key[0] if key else None
			if not key:
				return {'json': {'success': False, 'error': 'Missing required parameter: key'}}

			try:
				# Check if key exists using system.redis directly
				exists = system.redis.exists('redis', key)

				return {
					'json': {
						'success': True,
						'key': key,
						'exists': exists
					}
				}
			except Exception as e:
				return {
					'json': {
						'success': False,
						'error': str(e),
						'key': key
					}
				}

		elif action == 'test_dataset_native':
			# Test Dataset support using native system.dataset.toDataSet()
			try:
				# Create a dataset using the native Ignition approach
				headers = ["City", "Population", "Timezone", "GMTOffset"]
				data = [
					["New York", 8363710, system.date.now(), -5],
					["Los Angeles", 3833995, system.date.now(), -8],
					["Chicago", 2853114, system.date.now(), -6],
					["Houston", 2242193, system.date.now(), -6],
					["Phoenix", 1567924, system.date.now(), -7]
				]

				# Use the headers and data to create a Dataset
				original_dataset = system.dataset.toDataSet(headers, data)

				# Store and retrieve
				system.redis.set("redis", "test_native_dataset", original_dataset)
				retrieved_dataset = system.redis.get("redis", "test_native_dataset")
				system.redis.delete("redis", "test_native_dataset")

				# Test data integrity
				values_match = True
				sample_checks = []

				if retrieved_dataset:
					try:
						# Check a few specific values to ensure data integrity
						original_city = original_dataset.getValueAt(0, 0)
						retrieved_city = retrieved_dataset.getValueAt(0, 0)
						sample_checks.append({
							'field': 'first_city',
							'original': str(original_city),
							'retrieved': str(retrieved_city),
							'match': original_city == retrieved_city
						})

						original_pop = original_dataset.getValueAt(1, 1)
						retrieved_pop = retrieved_dataset.getValueAt(1, 1)
						sample_checks.append({
							'field': 'la_population',
							'original': str(original_pop),
							'retrieved': str(retrieved_pop),
							'match': original_pop == retrieved_pop
						})

						original_date = original_dataset.getValueAt(2, 2)
						retrieved_date = retrieved_dataset.getValueAt(2, 2)
						sample_checks.append({
							'field': 'chicago_date',
							'original_type': str(type(original_date)),
							'retrieved_type': str(type(retrieved_date)),
							'both_dates': 'Date' in str(type(original_date)) and 'Date' in str(type(retrieved_date))
						})

						values_match = all(check.get('match', check.get('both_dates', False)) for check in sample_checks)
					except Exception as e:
						sample_checks.append({'error': str(e)})
						values_match = False

				return {
					'json': {
						'success': True,
						'approach': 'system.dataset.toDataSet()',
						'original_type': str(type(original_dataset)),
						'retrieved_type': str(type(retrieved_dataset)),
						'types_match': type(original_dataset) == type(retrieved_dataset),
						'original_rows': original_dataset.getRowCount(),
						'original_cols': original_dataset.getColumnCount(),
						'retrieved_rows': retrieved_dataset.getRowCount() if retrieved_dataset else 0,
						'retrieved_cols': retrieved_dataset.getColumnCount() if retrieved_dataset else 0,
						'structure_matches': (
							original_dataset.getRowCount() == (retrieved_dataset.getRowCount() if retrieved_dataset else 0) and
							original_dataset.getColumnCount() == (retrieved_dataset.getColumnCount() if retrieved_dataset else 0)
						),
						'is_dataset': 'Dataset' in str(type(retrieved_dataset)),
						'column_names_match': (
							[original_dataset.getColumnName(i) for i in range(original_dataset.getColumnCount())] ==
							([retrieved_dataset.getColumnName(i) for i in range(retrieved_dataset.getColumnCount())] if retrieved_dataset else [])
						),
						'values_match': values_match,
						'sample_checks': sample_checks
					}
				}
			except Exception as e:
				import traceback
				return {
					'json': {
						'success': False,
						'error': str(e),
						'traceback': traceback.format_exc()
					}
				}

		elif action == 'test_dataset':
			# Test Dataset support
			try:
				# Build a test dataset with different data types using native approach
				test_date = system.date.now()
				headers = ["ID", "Name", "Score", "Active", "Timestamp"]
				data = [
					[1, "Alice", 95.5, True, test_date],
					[2, "Bob", 87.2, False, test_date],
					[3, "Charlie", 92.0, True, test_date]
				]

				original_dataset = system.dataset.toDataSet(headers, data)

				# Test storing and retrieving the dataset
				system.redis.set("redis", "test_dataset", original_dataset)
				retrieved_dataset = system.redis.get("redis", "test_dataset")
				system.redis.delete("redis", "test_dataset")

				return {
					'json': {
						'success': True,
						'original_type': str(type(original_dataset)),
						'retrieved_type': str(type(retrieved_dataset)),
						'types_match': type(original_dataset) == type(retrieved_dataset),
						'original_rows': original_dataset.getRowCount(),
						'original_cols': original_dataset.getColumnCount(),
						'retrieved_rows': retrieved_dataset.getRowCount() if retrieved_dataset else 0,
						'retrieved_cols': retrieved_dataset.getColumnCount() if retrieved_dataset else 0,
						'structure_matches': (
							original_dataset.getRowCount() == (retrieved_dataset.getRowCount() if retrieved_dataset else 0) and
							original_dataset.getColumnCount() == (retrieved_dataset.getColumnCount() if retrieved_dataset else 0)
						),
						'is_dataset': 'Dataset' in str(type(retrieved_dataset))
					}
				}
			except Exception as e:
				import traceback
				return {
					'json': {
						'success': False,
						'error': str(e),
						'traceback': traceback.format_exc()
					}
				}

		elif action == 'test_date_utils':
			# Test Date handling in RedisUtils without Redis
			from dev.bwdesigngroup.redis.common.util import RedisUtils

			try:
				# Create a Date object
				original_date = system.date.now()

				# Test RedisUtils.toPythonObject with a Date
				python_result = RedisUtils.toPythonObject(original_date)

				return {
					'json': {
						'success': True,
						'original_type': str(type(original_date)),
						'python_result_type': str(type(python_result)),
						'original_millis': original_date.getTime(),
						'python_result_str': str(python_result),
						'types_match': type(original_date) == type(python_result),
						'is_date_preserved': 'java.util.Date' in str(type(python_result))
					}
				}
			except Exception as e:
				import traceback
				return {
					'json': {
						'success': False,
						'error': str(e),
						'traceback': traceback.format_exc()
					}
				}

		elif action == 'test_user_scenario':
			# Exact replication of user's scenario
			try:
				connectionName = "redis"
				key = "example"
				value = system.date.now()

				# Store the date
				system.redis.set(connectionName, key, value)

				# Get it back
				retrieved = system.redis.get(connectionName, key)

				# Clean up
				system.redis.delete(connectionName, key)

				return {
					'json': {
						'success': True,
						'original_value': str(value),
						'original_type': str(type(value)),
						'retrieved_value': str(retrieved),
						'retrieved_type': str(type(retrieved)),
						'types_match': type(value) == type(retrieved),
						'is_original_date': 'java.util.Date' in str(type(value)),
						'is_retrieved_date': 'java.util.Date' in str(type(retrieved)),
						'retrieved_is_string': isinstance(retrieved, str)
					}
				}
			except Exception as e:
				import traceback
				return {
					'json': {
						'success': False,
						'error': str(e),
						'traceback': traceback.format_exc()
					}
				}

		elif action == 'debug_batch':
			# Debug batch operations directly
			try:
				# Create a simple batch operation manually
				batch_op = system.redis.createBatchOperation("op1", "set")
				batch_op.key("test:direct:batch")
				batch_op.value("direct_value")

				operations = [batch_op]

				# Execute batch directly
				results = system.redis.batch("redis", operations)

				# Check if the value was actually set
				check_result = system.redis.get("redis", "test:direct:batch")

				# Clean up
				system.redis.delete("redis", "test:direct:batch")

				return {
					'json': {
						'success': True,
						'batch_results': results,
						'actual_value': check_result,
						'value_set_correctly': check_result == "direct_value"
					}
				}
			except Exception as e:
				import traceback
				return {
					'json': {
						'success': False,
						'error': str(e),
						'traceback': traceback.format_exc()
					}
				}

		elif action == 'debug_date':
			# Simple Date test to verify serialization is working
			try:
				test_date = system.date.now()
				system.redis.set('redis', 'debug:date', test_date)
				retrieved_value = system.redis.get('redis', 'debug:date')
				system.redis.delete('redis', 'debug:date')

				return {
					'json': {
						'success': True,
						'original_type': str(type(test_date)),
						'original_millis': test_date.getTime(),
						'retrieved_type': str(type(retrieved_value)),
						'retrieved_value': str(retrieved_value),
						'is_date': isinstance(retrieved_value, Date),
						'values_equal': test_date.getTime() == (retrieved_value.getTime() if isinstance(retrieved_value, Date) else -1)
					}
				}
			except Exception as e:
				import traceback
				return {
					'json': {
						'success': False,
						'error': str(e),
						'traceback': traceback.format_exc()
					}
				}

		elif action == 'keys':
			pattern = params.get('pattern', '*')
			if isinstance(pattern, list):
				pattern = pattern[0] if pattern else '*'

			try:
				# Get keys matching pattern using system.redis directly
				keys = system.redis.keys('redis', pattern)

				return {
					'json': {
						'success': True,
						'pattern': pattern,
						'keys': list(keys) if keys else [],
						'count': len(keys) if keys else 0
					}
				}
			except Exception as e:
				return {
					'json': {
						'success': False,
						'error': str(e),
						'pattern': pattern
					}
				}

		else:
			return {'json': {'success': False, 'error': 'Unknown action: ' + str(action)}}

	except Exception as e:
		import traceback
		return {
			'json': {
				'success': False,
				'error': str(e),
				'type': type(e).__name__,
				'traceback': traceback.format_exc()
			}
		}
